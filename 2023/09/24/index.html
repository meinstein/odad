<!DOCTYPE html>
<html lang="en">

  <head>
    <meta charset="UTF-8">
    <meta name="description" content="...">
    <meta name="keywords" content="...">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>where's the bread?</title>
    <style>
      @keyframes dash {
        0% {
          stroke-dashoffset: 100%;
          stroke-opacity: 0;
        }

        10% {
          stroke-dashoffset: 90%;
          stroke-opacity: 0.5;
        }

        50% {
          stroke-dashoffset: 0%;
          stroke-opacity: 0.5;
        }

        90% {
          stroke-dashoffset: -90%;
          stroke-opacity: 0.5;
        }

        100% {
          stroke-dashoffset: -100%;
          stroke-opacity: 0;
        }
      }
    </style>
  </head>

  <body>
    <main>
    </main>
    <script>
      const WIDTH = 350;
      const HEIGHT = 350;

      // create a square svg element
      const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
      svg.setAttribute('width', WIDTH);
      svg.setAttribute('height', HEIGHT);
      svg.setAttribute('viewBox', `0 0 ${WIDTH} ${HEIGHT}`);
      svg.setAttribute('xmlns', 'http://www.w3.org/2000/svg');
      svg.setAttribute('version', '1.1');
      svg.setAttribute('xmlns:xlink', 'http://www.w3.org/1999/xlink');
      document.querySelector('main').appendChild(svg);

      // create a list of points in a grid layout across the entire svg element
      const points = [];
      const gridSize = 10;
      const gridWidth = WIDTH / gridSize;
      const gridHeight = HEIGHT / gridSize;

      for (let i = 0; i < gridSize; i++) {
        for (let j = 0; j < gridSize; j++) {
          points.push({
            x: i * gridWidth + 10,
            y: j * gridHeight + 10
          });
        }
      }

      // add the points to the svg element
      points.forEach(point => {
        const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
        circle.setAttribute('cx', point.x);
        circle.setAttribute('cy', point.y);
        circle.setAttribute('r', '5');
        circle.setAttribute('fill', 'none');
        circle.setAttribute('stroke', 'black');
        circle.setAttribute('stroke-width', '1')
        svg.appendChild(circle);

      });

      const addPath = ({ x1, y1, x2, y2 }) => {
        const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        path.setAttribute('stroke', 'indianred');
        path.setAttribute('stroke-width', '8');
        path.setAttribute('stroke-linecap', 'round');
        path.setAttribute('fill', 'none');
        path.setAttribute('stroke-opacity', '0')
        path.setAttribute('d', `M${x1},${y1} L${x2},${y2}`);
        // const length = path.getTotalLength();
        path.setAttribute('stroke-dasharray', '100%');
        path.setAttribute('stroke-dashoffset', '100%');
        path.style.animationName = 'dash';
        path.style.animationDuration = `${Math.min(Math.random() * 3000), 1500}ms`;
        path.style.animationTimingFunction = 'linear';
        path.style.animationDelay = '200ms';
        addAnimationEnd(path);
        svg.appendChild(path);
      }

      const getRandPoint = () => {
        return points[Math.floor(Math.random() * points.length)];
      }

      const addAnimationEnd = (path) => {
        let { x: x2, y: y2 } = getRandPoint();
        const { x2: x1, y2: y1 } = getEndPoint(path);

        // make sure the new point is not the same as the previous point
        while (x1 === x2 && y1 === y2) {
          ({ x: x2, y: y2 } = getRandPoint());
        }

        // has to be on a different grid line
        while (x1 === x2 || y1 === y2) {
          ({ x: x2, y: y2 } = getRandPoint());
        }

        // cannot be further than 4 grid lines away
        while (Math.abs(x1 - x2) > gridWidth * 4 || Math.abs(y1 - y2) > gridHeight * 4) {
          ({ x: x2, y: y2 } = getRandPoint());
        }

        path.addEventListener('animationend', (event) => {
          addPath({ x1, y1, x2, y2 });
          event.target.remove();
        });
      }

      const getEndPoint = (path) => {
        const [x2, y2] = path.getAttribute('d').split('L')[1].split(',');
        return {
          x2: parseInt(x2),
          y2: parseInt(y2)
        };
      }

      init = () => {
        const pointA = getRandPoint();
        const pointB = getRandPoint();

        addPath({
          x1: pointA.x,
          y1: pointA.y,
          x2: pointB.x,
          y2: pointB.y
        });
      }

      init();
    </script>
  </body>

</html>
