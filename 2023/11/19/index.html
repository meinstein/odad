<!DOCTYPE html>
<html lang="en">

  <head>
    <meta charset="UTF-8">
    <meta name="description" content="...">
    <meta name="keywords" content="...">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>add title here</title>
    <style>
      /* add styles here */
    </style>
  </head>

  <body>
    <main>
      <!-- add main content here -->
    </main>
    <script>
      const getDims = () => {
        const width = window.innerWidth;
        const height = window.innerHeight;
        return { width, height };
      };

      const { width, height } = getDims();

      const main = document.querySelector('main');
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      canvas.width = width;
      canvas.height = height;
      main.appendChild(canvas);

      // draw a rectangle dead center
      ctx.fillStyle = 'indianred';
      ctx.fillRect(width / 2 - 5, height / 2 - 50, 10, 100);

      let rotation = 0;

      let dots = [
        []
      ];
      let activeSubArray = 0;
      let isActive = true;
      let PATH_LENGTH = 180;
      let DIR = 1;

      const animate = () => {
        ctx.clearRect(0, 0, width, height);
        ctx.save();
        ctx.translate(width / 2, height / 2);
        ctx.rotate(rotation);

        // push the distance based on the prev rotation from the last dot in the active sub array
        if (isActive) {
          const lastDot = dots[dots[activeSubArray].length - 1];
          dots[activeSubArray].push({
            rotation,
            distance: lastDot ? lastDot.distance + Math.random() * 5 : 0
          });
        }

        ctx.fillStyle = 'indianred';
        ctx.fillRect(-5, -50, 10, 100);
        // emit a circle dot from the top of the rectangle on either side
        // ctx.beginPath();
        // ctx.arc(0, -50, 5, 0, Math.PI * 2);
        // ctx.fill();
        // ctx.beginPath();
        // ctx.arc(0, 50, 5, 0, Math.PI * 2);
        // ctx.fill();

        // draw the dots
        ctx.fillStyle = 'black';
        for (let i = 0; i < dots.length; i++) {
          dots[i].forEach(dot => {
            ctx.beginPath();
            ctx.arc(
              // line up the arc with the rectangle end points
              Math.cos(dot.rotation) * dot.distance * 0.5 * DIR,
              Math.sin(dot.rotation) * dot.distance,
              2,
              0,
              Math.PI * 2
            );
            // fade the further away the dot is
            ctx.globalAlpha = 1 - dot.distance / 1000;
            ctx.fill();
          });
        }

        ctx.restore();
        rotation += 0.01;

        if (rotation > Math.PI * 2) {
          rotation = 0;
        }

        // update the distance of the active sub array
        for (let i = 0; i < dots.length; i++) {
          dots[i].forEach(dot => {
            dot.distance += Math.random();
          });
        }

        const lastDotPath = dots[dots.length - 1];
        if (lastDotPath.length > PATH_LENGTH) {
          // Push new array for new path
          dots.push([]);
          activeSubArray++;
          isActive = false;
          setTimeout(() => {
            isActive = true;
            PATH_LENGTH = Math.random() * 180;
            // DIR = Math.random() > 0.5 ? 1 : -1;
          }, 1000);
        }

        // Look for distances past threshold in the sub arrays
        dots.forEach(dotPath => {
          let isPastThreshold = false
          dotPath.forEach((dot, i) => {
            if (dot.distance > 10_000) {
              isPastThreshold = true;
            }
          });
          if (isPastThreshold) {
            // Remove the sub array
            dots = dots.filter(path => path !== dotPath);
          }
        });

        requestAnimationFrame(animate);
      };

      animate();

    </script>
  </body>

</html>
